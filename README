
                 _,.---------------------------------------------+
             ,-"                                                 ;
            ,;                                                   ;
            !                                                    ;
            :.           ,----------------------------,          ;
             :,          ",                           ;          ;
              :.          :,                          ;          ;
               ',          ',                         ;          ;
                ',          ',                        ;          ;
                 ',          ',                      .;          ;
                  ',          ',                   ,-"           ;
                   ',          ',               ,-'             .|
                    ',          ',           ,-'              ,-"
                     ',          ',       ,-'              ,-'
                      ',          ',   ,-'              ,-'
                       ',          ',-'              ,-'
                        ',          '             ,-'
                         ',                    ,-'
                          ',                ,-'
                           ',            ,-'
                            ',        ,-'
                             ',   _,-'
                               ","


                                    _ＯＤＫＯ_

                     a minimal graphical programming language.

- DESCRIPTION @L36
- LANGUAGE DESIGN @L43
- SYNTAX AND EXAMPLES @L56
- EVENTS @L66
- KEYBOARD SHORTCUTS @L106

[ DESCRIPTION ]

the main purpose is to make it look cool and make working in it cool enough just
because  you  want  to  feel like a cool hacker, functionality is the last of my
concerns  and  the  language  is  being  designed as i'm going through it but it
doesn't matter as long as it's cool.

[ LANGUAGE DESIGN ]

> everything is vague right now, but this gives a broad outline of what i'm
  trying to accomplish and will aid in development

you  have blocks as rows in columns, you then connect the blocks mostly linearly
and the program is executed in parallel in that order.

each  block  contains  a  command  and  arguments for it, it then passes what it
returns  down  to the connected block(s). because odko is event-driven each line
should start with an event command,  and then when that event occurs the program
branches out from that first block by activating the connected blocks.

[ SYNTAX AND EXAMPLES ]

look in the  code/ folder in this repository, depending on how far i have gotten
in working on this project  there will be either screenshots of code in the odko
ui or plaintext representations of code.

yes, i am planning on coming up with a way to write plaintext odko code,  and it
may be presented with a tui version of odko as well.

[ EVENTS ]

> if a block is in the first column, and it starts with  "o",  "k", or "c",  the
  block will be ignored when (and only when) testing, even if it is connected
> events are only valid when placed in the first column (for now?)

most  events  have argument locations,  which are places the interpreter expects
you to have entered an argument.  the # argument(s)  are required,  and capitals
(when stated as having such meaning) are optional arguments.

some  events can be followed by a numerical id so the interpreter knows in which
order  to  execute multiple instances of an event, by default all events have an
id of 0 which means they will run as soon as possible, if multiple events of the
same  type and id are present, they will execute in the order they appear in the
starting column (top to bottom) this fact also holds true for events that do not
permit you to input an id through an argument.

sometimes optional arguments take the form of 'switches',  basically a 0 or 1 or
more value (depending on function, 0 or 1 if not stated otherwise) which enables
or disables something to make the event more specific/etc. you get it hopefully.

events return their position in the starting column unless specified otherwise

  [ onRun X ]
   blocks connected to this block will run as soon as possible after the program
   has begun execution. the event can be assigned an id via. the X argument.

  [ k_# ABC ]
   blocks  connected  to this block will run after the key # has been depressed.
   A,  B,  and  C  are switches which  enable  or disable the requirement of the
   Shift, Ctrl, or  Alt  modifiers modifier keys  respectively. the switches can
   also  be omitted or replaced with a question mark  (?)   (eg. if you need the
   Shift  and  Alt  keys  to be held, but don't care about the state of the Ctrl
   key, your ABC would be "1?1")

  [ k-# ABC ]
   same as previous event except fires after a key has been released.

  [ c##_ABC ]
   same as the  [ k_# ]  event except instead of a character you would input two
   hexadecimal digits that represent a javascript keycode.

  [ c##-ABC ]
   same as the  [ k-# ]  event except instead of a character you would input two
   hexadecimal digits that represent a javascript keycode.

[ KEYBOARD SHORTCUTS ]

> ^ is short for  "ctrl + ..."  and  capital  letters imply shift being pressed,
  slashes  delimitate  aliases  of  a  certain  function, and shortcuts that are
  longer  than  one or two characters and begin with a capital represent special
  keys on the keyboard
> we  call  them keyboard shortcuts but there's no mouse control implemented yet
  so they are really the only kind of control you have right now

- DEFAULT MODE @L121
- EDIT MODE @L136
- CONNECT MODE @L145
- MOVE MODE @L153
- RUN MODE @L157

A) default mode
  a: add block
  A: add column
  x: remove block
  Delete: remove column
  `: enter run mode (show console)
  Z: toggle debug view
  t: test current block
  g: move block (enters move mode)
  c: connect block (enters connect mode)
  d: disconnect connection to the current block
  D: disconnect connections originating from current block
  e/Enter/F2: edit block (enters edit mode)
  Arrow Keys: change focus

B) edit mode
  Escape/Enter: exit edit mode
  ArrowLeft/Right: move edit cursor
  ArrowUp/Home: move cursor to start of block
  ArrowDown/End: move cursor to end of block
  Backspace: delete character behind cursor
  Delete: delete character in front of cursor
  normal typing: normal typing

C) connect mode
  Escape/c: exit connect mode and cancel connection
  Enter/C: exit connect mode and confirm connection
  ArrowRight: select column right of the focused block
  ArrowLeft: select column left of the focused block
  ArrowUp/Down: change selected block
  d: if the highlighted connection exists, disconnect it

D) move mode
  Escape/Enter/g: exit move mode
  Arrow Keys: move block

E) run mode
  `: exit run mode (hide console)
  Tab: start execution
  Shift + Tab/F12: halt execution (discard set registers)
  Shift + F12: halt execution (preserve set registers)
